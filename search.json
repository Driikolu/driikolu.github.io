[{"categories":null,"content":" Du 27 au 29 Juin 2025 s’est tenu Le Hack, à la cité des sciences de Paris. Pour l’occasion, des centaines de professionnels de la sécurité, d’étudiants ou de simples curieux, se sont réunis pour parler de Hacking, d’OSINT, et de sécurité. Comme chaque année, de nombreuses entreprises, écoles, associations ou entités publiques étaient présentes. Notamment YesWeHack qui cette année a proposé un petit challenge pour le moins intéréssant et qui vaut la peine d’être décortiquer. One Payload to rule them all Le challenge, affectueusement nommé “Payload Plz” (Ou comme nos amis Québécois diraient “Charge utile Svp”), a un principe simple : Il y a 13 petits challenges en tout genre (SQLi, SSTI, XSS, …) et nous devons en résoudre le plus possible avec 1 seule et même payload, et la plus courte possible. Notre payload nous donnera un score calculé ainsi : score = (nombre de challenges résolus × 1000) − taille de la payload Le challenge n’a duré que 2 jours, en parallèle des conférences, accessibles à tous. Je suis personnellement arrivé 10ème, avec une payload de 356 caractères permettant de résoudre 12 des 13 challenges. L’objectif de ce blogpost sera donc de voir comment je suis arrivé à cette payload puis d’analyser celle de ceux arrivés plus haut dans le classement. Nota bene : Les payloads que j’ai utilisé ne sont clairement pas les plus courtes, mais par soucis de transparence je les présenterais telles quelles. Les 13 challenges individuellement La première étape, pour bien commencer, est de résoudre tous les challenges individuellement. Cela nous permettra d’avoir une base sur laquelle travailler notre payload. À savoir par avance que tous les challenges sont “à l’aveugle”. Nous n’aurons jamais la sortie, qu’il y ai une erreur ou non. Notre seule information étant si la paylaod a résolu le challenge, c’est à dire si le flag apparait dans la sortie. XSS 1 Pour ce challenge, il fallait déclencher un appel à alert(flag) par un bot chromium à jour. Aucune protection n’était appliquée et notre payload était injectée dans le code suivant (à la place de $INPUT): \u003ch1\u003eHello $INPUT\u003c/h1\u003e La manière la plus simple pour celle-ci étant de simplement ajouter une balise \u003cscript\u003e contenant notre code javacript. \u003cscript\u003ealert(flag)\u003c/script\u003e On test. Le challenge est résolu. On passe au suivant. XSS 2 Seconde XSS où l’objectif est le même : alert(flag). Cependant le code est différent : \u003cscript\u003econst x = '$INPUT'\u003c/script\u003e Ici, nous somme directement dans une balise script. Il faut sortir de la string, executer notre alert et terminer le code proprement. Voici une solution : '; alert(flag)/* Le commentaire à la fin de la payload permet d’ignorer totalement la quote et donc de rendre le code valide. SQL Injection 1 On change de type de vulnérabilité avec les injections SQL. On nous fourni cette fois le schéma de base de données avec l’instruction de lire la colonne flag de la table flag : CREATE TABLE users (username TEXT, password TEXT, age INTEGER); CREATE TABLE flag (flag TEXT); Et encore une fois le code (enfin la requête) dans lequel nous devons injecter : SELECT * FROM users WHERE username = '$INPUT' Nous avons cependant quelques informations en plus : La payload n’est toujours pas “nettoyée” La DBMS est SQLite3 La payload est normalisée en NFKC Mais pas besoin de savoir tout cela pour trouver une payload directement : ' UNION SELECT 1,2,flag FROM flag; Et on termine par un point virgule ; afin de terminer la requête et d’éviter les erreurs, la quote d’après étant ignorée. SQL Injection 2 Globalement ce challenge est exactement le même que le précédent à une seule différence : notre input n’est pas entrée en string (Elle n’est pas entre quotes) : SELECT * FROM users WHERE age \u003c$INPUT Nous sommes ici aussi sur une solution relativement simple : 1 UNION SELECT 1,2,flag FROM flag Et cette fois, pas besoin de commentaire ou de point virgule, la requête sera valide telle quelle. XPath Injection Pour ce challenge, un petit XML nous est présenté : \u003cd","date":"2025-07-06","objectID":"/posts/payload-plz/:0:0","tags":null,"title":"Payload Plz - Analyse du challenge Yes We Hack","uri":"/posts/payload-plz/"},{"categories":null,"content":"Introduction Le 1er Avril 2022 a eu lieu de BreizhCTF, et ce, 3 ans après la dernière édition. Bien sûr, j’ai voulu y participer. Et comme d’habitude il y a eu plein de challenges intéréssant. Mais je n’ai pas spécialement envie de parler d’une énième XSS qui mènera à une RCE ou de comment retrouver un domaine avec des requêtes modifiées… Ou tout autre truc du genre. Aujourd’hui, on va parler de programmation ! Et je vais essayer de bien tout détailler Le challenge Il y avait en tout 3 challenges de programmation, je n’ai touché qu’à celui dont je vais vous parler : Word Worker. Le but est simple : se connecter à un serveur et résoudre les petits challenges qu’il nous propose. En boucle. Pas de problème, je suis coutumier de ce genre de puzzle, je dégaine mon python et c’est partie pour un petit moment de code. Se connecter au serveur On oublie souvent d’en parler de cette étape, probablement parce qu’elle n’est pas très intéréssante, mais j’ai tout de même un petit point à apporter. Dans ce genre de Challenge, je vois beaucoup de gens habitués aux CTF en tout genre utiliser pwntools. L’outil est très puissant et embarque directement une gestion des socket. Mais en soit il n’est pas vraiment adapté à ce genre de challenge… C’est l’équivalent d’utiliser un bazooka pour tuer une mouche : Ça fonctionne, mais était-ce vraiment nécessaire, et est-ce qu’on se serait pas un peu compliqué la vie ? Pour ma part, j’opte pour une solution simple : socket, que je couple avec time pour ne pas répondre trop vite. import socket import time s = socket.socket() #On créé notre socket s.connect(('challenges.ctf.bzh', 27001)) #On se connecte au serveur time.sleep(1) #On laisse le temps de se connecter au serveur while True: time.sleep(0.1) #Pour laisser le temps de recevoir le message output = s.recv(2048).decode() #On récupère le message et on le passe de Byte-string à string print(output) #Pour avoir la visibilité sur ce qu'il se passe res=\"Ma réponse\" s.send(res.encode()+b\"\\n\") #On envoie notre réponse (en Byte-String et on oublie le \\n pour qu'elle soit envoyée) Parfait, tout est en place, on va pouvoir commencer vraiment le challenge. Trouver l’anagramme Dès notre connexion, on se retrouve avec un message plutôt simple : Which word is mixed up ? XXXXXXX On retrouve alors un ensemble de lettre avec seulement 1 lettre majuscule. Avec la phrase en plus, on comprend qu’il s’agit d’un anagramme dont il faut retrouver le mot d’origine. La lettre majuscule étant la première lettre du mot. Itertools ? Une première idée était d’utiliser itertools. Mais, au moment de sa sortie, ce challenge proposait des mots de toute taille, parfois de plus de 10 lettres. Par exemple, s’il fallait trouvé Zygomatiques depuis un de ses anagrammes, on aurait un total de 11! (soit 39.916.800) possibilités. Il y a de forte probabilités pour que le mot soit trouvé avant toutes les itérations. Mais même en trouvant au bout de 1.000.000 itérations, le temps passer pour 1 seul mot est plutôt conséquent. Après une petite maintenance le challenge est revenu en ne proposant que des mots de 5/6 lettres, mais ma solution était déjà écrite. Un dictionnaire ! Heureusement, ce sont les anagramme de mots français. Et par chance, il existe un dictionnaire plutôt complet pour les mots en français : ods6.txt, le dictionnaire officiel du scrabble. Et on s’empresse de coder une fonction retrouvant l’anagramme. Tout d’abord, il faut avoir la liste de tous les mots présents dans notre dictionnaire. dico_words = open(\"ods6.txt\",\"r\").read().split() Maintenant, comment peut-on retrouver notre mot ? Tout d’abord il faut repérer les critères qu’on peut utiliser : La première lettre du mot L’ensemble des lettres Ça fait peut, et le tout doit être formatté comme il faut. Notre dictionnaire a tous ses mots en majuscule, on fait de même avec notre anagramme. #On récupère la seule lettre en majuscule, première lettre du mot first_letter = [l for l in anagramme if l.isupper()][0] #On met l'anagramme en","date":"2022-04-07","objectID":"/posts/word_worker_wu/:0:0","tags":null,"title":"BreizhCTF 2022 - Word Worker","uri":"/posts/word_worker_wu/"},{"categories":null,"content":"Durant le confinement, j’étais particulièrement actif sur HackTheBox. Ayant fait toutes les boxs que je jugeait “à ma portée” à un moment je m’étais lancé dans la quête (qui me paraissait impossible) d’une box notée Insane ! Ainsi j’ai réussi Fatty non sans difficulté. J’ai trouvé l’expérience assez intéréssante pour en faire un Write-Up que vous pouvez lire juste en dessous ! Trouver un point d’entrée sudo nmap -p 0-10000 -T5 -Pn -O -sV 10.10.10.174 Nmap scan report for 10.10.10.174 Host is up (0.039s latency). Not shown: 9996 closed ports PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.0.8 or later 22/tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u7 (protocol 2.0) 1337/tcp open ssl/waste? 1338/tcp open ssl/wmc-log-svc? 1339/tcp open ssl/kjtsiteserver? 3 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port1337-TCP:V=7.80%T=SSL%I=7%D=4/4%Time=5E88607F%P=x86_64-unknown-linu SF:x-gnu%r(NULL,80,\"\\xe4\\xdb\\xb8\\xe4_\\x13\\x96T\\t\\xf3r\\xa7m\\xc8h\\x87\\xc8\\xf \u003cREDACTED\u003e ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port1338-TCP:V=7.80%T=SSL%I=7%D=4/4%Time=5E88607F%P=x86_64-unknown-linu SF:x-gnu%r(NULL,80,\"C\\xec\\\"r\\xfd\\x89}\\|\\x1d\\xddW\\x1b\\xf8ux\\xf6\\x15B\\xf4\\x9 \u003cREDACTED\u003e ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port1339-TCP:V=7.80%T=SSL%I=7%D=4/4%Time=5E88607F%P=x86_64-unknown-linu SF:x-gnu%r(NULL,80,\"\\\"\\.\\x0b\\xb1\\xcfd\\x1a\\xc3\\x9c\\xce\\0\\xd7\\x982\\xac\\x99\\x \u003cREDACTED\u003e Aggressive OS guesses: Linux 3.2 - 4.9 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), Linux 3.12 (94%), Linux 3.13 (94%), Linux 3.16 (94%), Linux 3.18 (94%), Linux 3.8 - 3.11 (94%), Linux 4.4 (94%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel On peut voir : 1 service FTP (21) 1 service SSH (22) 3 services inconnus (1337,1338,1339) Le FTP Dans un premier temps, l’option la plus logique est de tester une connexion anonyme au FTP. On a en effet un accès et quelques fichiers potentiellement intéréssants 3 fichiers textes 1 fichier executable jar On s’empresse de récupérer tous ces fichiers puis on lit les notes. Note 1 Dear members, because of some security issues we moved the port of our fatty java server from 8000 to the hidden and undocumented port 1337. Furthermore, we created two new instances of the server on port 1338 and 1339. They offer exactly the same server and it would be nice if you use different servers from day to day to balance the server load. We were too lazy to fix the default port in the ‘.jar’ file, but since you are all senior java developers you should be capable of doing it yourself ;) Best regards, qtc Note 2 Dear members, we are currently experimenting with new java layouts. The new client uses a static layout. If your are using a tiling window manager or only have a limited screen size, try to resize the client window until you see the login from. Furthermore, for compatibility reasons we still rely on Java 8. Since our company workstations ship Java 11 per default, you may need to install it manually. Best regards, qtc Note 3 Dear members, We had to remove all other user accounts because of some seucrity issues. Until we have fixed these issues, you can use my account: User: qtc Pass: clarabibi Best regards, qtc Bien… La suite se passe donc sur le client jar. Le client jar La première chose à faire c’est d’essayer d’executer le client normalement. Pour cela, rien de plus simple ! java -jar fatty-client.jar On arrive sur une page de login, on test les identifiants donnés dans la 3ème note ( qtc / clarabibi ) et… Ça ne fonctionne pas. On obient un Connection Error ! Réussir à se connecter Si on se réfère à la première note : le port du serveur à chang","date":"2020-08-09","objectID":"/posts/fatty-wu/:0:0","tags":null,"title":"HackTheBox - Fatty Write-Up","uri":"/posts/fatty-wu/"},{"categories":null,"content":"Introduction Cet article peut servir de support pour installer ArchLinux avec des partitions root ( / ) et home ( /home ) chiffrées et le tout en UEFI. Pourquoi ArchLinux Il y a 3 grandes raisons qui me poussent à utiliser ArchLinux depuis maintenant plusieurs années. J’apprécie dans un premier temps la philosophie de cette distribution : Elle est développée pour être légère et “simple” (sans superflu). Elle se base sur l’idée que l’utilisateur comprend ce qu’il fait, elle laisse donc une totale liberté dans sa configuration. Elle est basée sur le libre \u0026 communautaire, tout le monde peut donc participer à l’amélioration de la distribution et des paquets Ensuite, en lien avec le dernier point, il existe sur ArchLinux le AUR (ArchLinux User Repository) : Des depots utilisateurs moins vérifiés mais permettant à n’importe qui de créer un paquet. On trouve facilement la majorité des outils disponible sous linux via l’AUR, ce qui est un plus dans la sécurité. Pour finir, le wiki ArchLinux est l’un des plus complets (si ce n’est le plus complet). On peut facilement s’y référer en cas de problèmes et pour en apprendre un peu plus sur nos outils ou sur le fonctionnement de Linux. Pourquoi chiffrer les partitions ? On peut considérer 2 contextes : Le contexte professionnel Le contexte privé Dans le contexte professionnel, on est souvent ammené à chiffrer nos données. En général ce travail est fait automatiquement par des services informatiques et des outils. On doit parfois configurer et utiliser un PC sous Linux, notamment pour les pentesteurs, et dans ce cas il faut chiffrer nous même nos données. Chiffrer les partitions permet à ce moment de ne pas avoir à gérer les fichiers à l’unité tout en apportant le minimum en terme de protection des données. Dans le contexte privé, tout le monde a son propre rapport à la vie privée. Lorsque l’on veut la protéger au maximum il est normal de vouloir chiffrer ses données. En comparaison au chiffrement fichier par fichier, le chiffrement des partitions permet de ne pas limiter son confort d’utilisation en déchiffrant celles-ci uniquement au démarrage du PC. L’installation Vous pourrez voir quelques captures d’écrans faites durant une installation. Pour l’exemple j’ai utilisé une machine virtuelle de 30Go, j’adapterais donc les valeurs des espaces disques pour coller mieux à des disque durs plus grands. Préparation Dans un premier temps, vous devez télécharger un liveboot et le mettre sur le support de votre choix (USB ou CD). Avant de vous lancer dans l’installation, vérifiez bien que vous avez votre BIOS en UEFI et non en Legacy. Je vais aussi considérer que vous êtes en filaire. Si vous voulez vous connecter en wifi, vous pouvez utiliser wifi-menu. Une fois le liveboot ArchLinux lancé, on va passer notre clavier en AZERTY. Si vous avez une autre disposition de clavier je vous invite à regarder sur le wiki spécifique. loadkeys fr On va ensuite régler notre horloge. Ce n’est pas toujours nécessaire mais cela peut parfois poser problème pour la vérification de paquets. Ici, je considère que vous utilisez l’heure française. timedatectl set-timezone Europe/Paris timedatectl set-ntp true Le partionnement Dans un tout premier temps, nous allons lister nos disques fdisk -l Ici, on peut voir que le disque que nous voulons utiliser est /dev/sda. Le disque /dev/loop0 correspondant à mon liveboot Arch. Pour le partitionnement j’ai décider de faire 4 partitions : Une partition EFI (pour l’UEFI) Une partition boot (pour le bootloader) Une partition root ( / ) Une partition home ( /home ) Dans le cadre de partitions chiffrées, il faut obligatoirement au moins une partition EFI en dehors. Pour des raisons de confort et de facilité j’ai décidé de garder un /boot non chiffré aussi (Il est selon moi, moins important de le chiffrer). Les partitions root et home seront chiffrées. Vous pouvez cependant ne faire que 3 partitions en ne faisant pas de partition home. Pour commencer le partitionnement, on ouvre notre di","date":"2020-03-24","objectID":"/posts/install_arch_uefi/:0:0","tags":null,"title":"Installation d'Archlinux en UEFI \u0026 chiffré","uri":"/posts/install_arch_uefi/"},{"categories":null,"content":"En janvier 2020, en marge du FIC, était organisé le NorzhCTF par l’ENSIBS. Cette année je ne faisais pas partie des “créateurs de challenges” mais bien des participants avec mes amis Haax, Razaborg et L0n3w0lf. Durant ce CTF, je me suis tout particulièrement occupé d’un scénario : Extranet Norzh Nuclea que vous pouvez retrouver sur le git du NorzhCTF. Énoncé On commence par lire l’énoncé Vous avez trouvé l’extranet de l’entreprise. Ce challenge se décompose en 4 parties : Obtenir un accés à l’interface administrateur Obtenir un shell sur la machine Obtenir un accès root sur la machine Obtenir le mot de passe de l’utilisateur web-dev Globalement, ça ressemble à de l’exploitation web puis une privesc système Linux… C’est tout à fait ce que je sais faire, donc on va se lancer. Obtenir l’accès administrateur Dans un premier temps on va un peu fouiller le site. On a 3 pages : Une page d’accueil Une page de blog Une page de login La page d’accueil ne me semble pas utile, je vais directement voir la page de blog. Ici, ça commence à devenir interéssant. Lorsque l’on regarde les liens des blogposts on obtient quelque chose comme ceci : http://www.norzh.nuclea/blog/2f6772617068716c3f[...]6222297b5f6964207469746c6520636f6e74656e747d7d Ça me paraît être quelque chose “encodé” en hexadécimal… On ouvre donc la console python, et on se fait une petite fonction pour décoder. def decode_hex(hex): return ''.join([chr(int(hex[i:i+2],16)) for i in range(0,len(hex),2)]) print(decode_hex(\"2f6772617068716c3f71756572793d7175657279207b626c6f67706f7374285f69643a2235646632363961323338356538393838356265636234356222297b5f6964207469746c6520636f6e74656e747d7d\")) Et on obtient le résultat suivant : /graphql?query=query {blogpost(_id:“5df269a2385e89885becb45b”){_id title content}} C’est donc une requête GraphL, on peut le comprendre avec le /graphql et au contenu de query. La requête est sans doute interprétée par le serveur pour nous obtenir le blogpost voulu… On doit pouvoir faire une injection là dessus. Trouver la table Je me suis donc un peu renseigné sur le sujet n’en ayant jamais fait et je trouve rapidement ce qu’il faut faire. Dans un premier temps, je me refait une petite fonction pour encoder toutes mes requêtes. from base64 import b16encode def encode_hex(str): return b16encode(b'/graphql?query=query '+str.encode()).decode() #encode() et decode() pour gérer les byte-strings La première étape pour obtenir le contenu de la base de données, c’est d’avoir toutes les tables présentes. En GrapQL ça s’obtient avec la requête { __schema { types { name } } } On va encoder tout ça et le mettre dans notre URL. http://www.norzh.nuclea/blog/2F6772617068716C3F7175657279[...]D61207B207479706573207B206E616D65207D207D207D Et là on a un blogpost vide… Pas d’inquiétude à avoir, en fait l’affichage est traité en js et le retour de notre requête n’est pas celui attendu. Donc on a juste à ouvrir les sources de la page. On voit bien la table BlogPost qui sert à la requête de base, mais nous on va s’intéresser à la ble User. Nos requêtes sont les suivantes : Trouver les colonnes { __type(name: \"User\") { name fields { name type { name kind } } } } Ici on récupère en plus les types de chaques colonnes {\"__type\": { \"name\":\"User\", \"fields\": [ { \"name\":\"_id\", \"type\": { \"name\":\"String\", \"kind\":\"SCALAR\" } }, { \"name\":\"username\", \"type\": { \"name\":\"String\", \"kind\":\"SCALAR\" } }, { \"name\":\"password\", \"type\": { \"name\":\"String\", \"kind\":\"SCALAR\" } } ] } } En résumé, nous avons 3 colonnes: _id username password On veut, pour avancer, récupérer ces deux dernières. Récupérer les valeurs On peut procéder de 2 manières : En requêtant toutes les valeurs de User une à une grâce à l’id En requêtant l’ensemble des valeurs de la table User. Étant un partisan du moindre effort, je choisis la seconde option. Et pour ce faire, il “suffit” de rajouter un s à la fin du nom de table. { users { username, password } } On obtient bien la liste de tous les couples username/password {\"users\": [ { \"usernam","date":"2020-02-06","objectID":"/posts/nuclea-web-extranet/:0:0","tags":null,"title":"Norzh CTF 2020 - Extranet Norzh Nuclea","uri":"/posts/nuclea-web-extranet/"}]